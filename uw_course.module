<?php
/**
 * 
 * 
 * @todo Implement paging based on page_size input by user. Currently a max list is returned
 */

/**
* Implements hook_help.
*
* Displays help and module information.
*
* @param path
*   Which path of the site we're using to display help
* @param arg
*   Array that holds the current path as returned from arg() function
*/
function uw_course_help($path, $arg) {
    $output = '';
    switch ($path) {
        case "admin/help#uw_course":
            $output .= '<h3>' . t('About UW Courses') . '</h3>';
            $output .= '<p>' . t("This module creates a content type \"UW Course List\".") . '</p>';
            $output .= '<p>' . t("The Fields are created based on the Course_search attributes as described on ");
            $output .= l('UW SWS Course Search Resource V4', 'https://wiki.cac.washington.edu/display/SWS/Course+Search+Resource+V4', array('attributes'=>array('target'=>'_blank',)));
            $output .= ', and are used as search criteria to create the course list.</p>';
            break;
    }
    return $output;
} 

/**
* Implements hook_menu().
* 
* The name of this hook is a bit misleading, as it does far more than simply assign menu items. 
* Using this hook, modules register paths to define how URL requests are handled.
*/
function uw_course_menu() {
    //$account = ($account == NULL) ? menu_get_object('user') : $account;
    $items = array();

    // path to test page
//    $items['uw_course'] = array(
//        'title' => 'UW Courses test devel',
//        'page callback' => '_uw_course_testpage',
//        'access callback' => TRUE,
//        'access argument' => array('access nodes'),
//        'type' => MENU_NORMAL_ITEM,
//    );

  return $items;
}

/**
 * Implements hook_node_info()
 * 
 * This hook can define one or more node types. 
 * 
 */
function uw_course_node_info() {
    return array(
        'uw_course_list' => array(
            'name' => t('UW Course List'),
            'base' => 'uw_course_list',
            'description' => t('Use this content type to retrieve a UW SWS Course List page.'),
            'has_title' => TRUE,
            'title_label' => t('UW Course List title'),
            'locked' => TRUE,
            // attributes below are not set through this hook, see uw_course_install()
            //'comment' => COMMENT_NODE_CLOSED,
            //'promote' => NODE_NOT_PROMOTED,
         )
    );
}

/**
 * Implement hook_form()
 * 
 * The hook_form hook is used to show the form used to create/edit nodes.
 * 
 */
function uw_course_list_form($node, $form_state) {
    return node_content_form($node, $form_state);
}

/**
 * Implements hook_form_BASE_FORM_ID_alter(&$form, &$form_state, $form_id).
 *
 * Modification for the form with the given BASE_FORM_ID goes here. For
 * example, if BASE_FORM_ID is "node_form", this code would run on every
 * node form, regardless of node type.
 *
 * @param $form
 *   Nested array of form elements that comprise the form.
 * @param $form_state
 *   A keyed array containing the current state of the form.
 * @param $form_id
 *   String representing the name of the form itself. Typically this is the
 *   name of the function that generated the form.
 * 
 * @todo field validation
 */
function uw_course_form_uw_course_list_node_form_alter(&$form, &$form_state, $form_id) {    
    // disable body field because we will render the content into it
    $form['body']['#access'] = FALSE;
}

/**
 * Helper function.
 * Initiates a cURL request or retrieves cached data based on url
 * 
 * @staticvar type $my_data
 * @param type $url
 * @return type
 * @throws Exception
 */
function _uw_course_get_curl($url) {
    try {
        static $my_data;
        $cache_key = $url;
        $bin = 'cache';
        $cache = cache_get($cache_key, $bin);
        
        if ($cache) {
            // get cached data
            //drupal_set_message('Getting cached data' , 'status');
            $my_data = unserialize($cache->data);
        } else {
            // Do expensive calculations here, and populate $my_data
            //drupal_set_message('Connecting to server "' . variable_get('uw_ws_domain') . '"' , 'status');
            $curl = curl_init();
            curl_setopt_array($curl, array(
                CURLOPT_RETURNTRANSFER => TRUE,
                CURLOPT_URL => $url,
            ));
            $response = curl_exec($curl);
            $http_status = curl_getinfo($curl, CURLINFO_HTTP_CODE);
            $info = curl_getinfo($curl);
            curl_close($curl);

            // load the HTTP codes
            $http_codes = parse_ini_file(variable_get('uw_sws_http_status_file'));

            if ($http_status === 200) {
                $response = json_decode($response);
                $my_data = $response;
                //drupal_set_message($http_status . ': ' . $http_codes[$info['http_code']], 'status');
            } else {
                //drupal_set_message($http_status . ': ' . $http_codes[$info['http_code']], 'warning');
                throw new Exception($http_codes[$info['http_code']], $http_status);
            }
              
            // populate cache  
            cache_set($cache_key,  serialize($my_data), $bin);
          }
        
        return $my_data;
        
    } catch (Exception $exc) {
        drupal_set_message($exc->getMessage(), 'error');
    }
}

/**
* Implements hook_node_view().
*
* Act on a node that is being assembled before rendering.
*
* The module may add elements to $node->content prior to rendering. This hook
* will be called after hook_view(). The structure of $node->content is a
* renderable array as expected by drupal_render().
*
* When $view_mode is 'rss', modules can also add extra RSS elements and
* namespaces to $node->rss_elements and $node->rss_namespaces respectively for
* the RSS item generated for this node.
* For details on how this is used, see node_feed().
*
* @see blog_node_view()
* @see forum_node_view()
* @see comment_node_view()
*
* @param $node
*   The node that is being assembled for rendering.
* @param $view_mode
*   The $view_mode parameter from node_view().
* @param $langcode
*   The language code used for rendering.
*
* @see hook_entity_view()
*
* @ingroup node_api_hooks
 * 
 * @todo optimize args array
 * @todo implement paging
*/
function uw_course_node_view($node, $view_mode, $langcode, $reset = FALSE) { 
    
    if ($node->type == 'uw_course_list') {
          
        $url = variable_get('uw_ws_domain') . variable_get('uw_sws_v4_public_course');
        if (!$url) { return drupal_set_message("Path to UW SWS not set.", "warning"); }   

        // get the values from the fields
        // trim, and replace space and ampersand
        $curriculum_abbreviation = trim(str_replace(array(' ', '&'), array('+', '%26'), $node->uw_course_curriculum_abbr[LANGUAGE_NONE][0]['value']));
        $quarter = $node->uw_course_quarter[LANGUAGE_NONE][0]['value'];
        $year = $node->uw_course_year[LANGUAGE_NONE][0]['value'];
        // field page_size is disabled until a paging method is implemented
        // for now return all the results based on maximum setting 500
        //$page_size = $node->uw_course_page_size[LANGUAGE_NONE][0]['value'];
        $page_size = ($page_size == '') ? 500 : $page_size;

        $args = array(
            'curriculum_abbreviation' => $curriculum_abbreviation,
            'quarter' => $quarter,
            'year' => $year,
            'page_size' => $page_size,
        );

        // create the querystring
        $terms = count($args);
        foreach ($args as $key => $value) {
            $terms--;
            $attributes .= $key . '=' . $value;
            ($terms) ? $attributes .= '&' : '' ;
        }
        $url = $url . '.json?' . $attributes;
        $response = _uw_course_get_curl($url);

        $markup .= '<div class="uw-courses">';
        foreach($response->Courses as $obj){
            $course = _uw_course_get_curl(variable_get('uw_ws_domain') . $obj->Href);
            //$htmlLink = variable_get('uw_ws_domain') . str_replace('.json','.xhtml',stripslashes($obj->Href));
            $markup .= '<div class="uw-course">';
            $markup .= '<h3>' . $obj->CurriculumAbbreviation . ' ' . $obj->CourseNumber . ' &ndash; ' . $obj->CourseTitle . '</h3>';
            //$markup .= '<h3><a href="' . $htmlLink . '" target="_blank">' . $obj->CurriculumAbbreviation . ' ' . $obj->CourseNumber . ' &ndash; ' . $obj->CourseTitle . '</a></h3>';
            $markup .= '<div class="uw-course-title-long"><em>' . $obj->CourseTitleLong . '</em></div>';
            $markup .= '<div class="uw-course-description">' . $course->CourseDescription . '</div>';
            //$markup .= '<div class="course-credit">Credit: ' . $course->CreditControl . '</div>';
            $markup .= '<div class="uw-course-college">College: ' . $course->CourseCollege . '</div>';
            $markup .= '<div class="uw-course-campus">Campus: ' . $course->CourseCampus . '</div>';
            $markup .= '</div>';
        }
        $markup .= '</div>';
        if ($response->TotalCount) { $markup = '<div id="resultStats">' . $response->TotalCount . ' courses found</div>' . $markup; }
    
        // workaround for empty $body: create empty p element and save node to trigger body value
        if (empty($node->body)) {
            $node->body[LANGUAGE_NONE][0]['value'] = '<p />';
            node_save($node);
        }
        $body = $node->body[LANGUAGE_NONE][0]['value'];
        
        $node->content['body'][0]['#markup'] = $body . $markup;
    }
}
